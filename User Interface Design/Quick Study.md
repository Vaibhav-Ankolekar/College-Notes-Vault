# Module 4

**Types of Prototyping**
- Low Fidelity Prototyping - Less details, doesn't look like final product
- High Fidelity Prototyping - More details looks like final product

**Compromises in Prototyping**
- Horizontal prototyping - providing wide range of functions but with little details
- Vertical prototyping - providing lots of detail for only few functions

**Principles of Conceptual Design**
- Keep and open mind but never forget the users and their context
- Discuss ideas with other stakeholders as much as possible
- Use prototyping to get rapid feedback
- Iterate, iterate and iterate

**Interface Design**
- An interface metaphor is a visual or conceptual analogy that connects the user's mental model of a familiar object or environment to the operation of a software application. 
- By using metaphors, designers can make complex software systems easier to use by leveraging the user's existing knowledge and experience.

**Steps for choosing a good Interface Metaphor**
1. Understand what the system will do (identifying the functional requirements)
2. Understand which tasks/subtasks of the product are likely to cause users problems
3. Generate metaphors

**Five Questions to ask for good metaphor**
1. How much structure does the metaphor provide?
2. How much of the metapgor is relevant to the problem?
3. Is the interface metaphor easy to represent?
4. Will your audience understant the metaphor?
5. How extensible is the metaphor?

# Module 5

**Universal Design Principles**
1. Equitable use
2. Flexibility in use
3. System be simple and intuitive to use
4. Perceptible information
5. Tolerance for error
6. Low physical effort
7. Requires size and space for approach and use

**Principles to support Usability**
- Learnability
- Flexibility
- Robustness

**Principles affecting Learnability**
- Predictability - Support for the user to determine the effect of future action based on past interaction history
- Synthesizability - Support for the user to access the affect of past operations on the current state
- Familiarity - The extent to which a user's knowledge and experience in the other real-world domains can be applied when interacting with a new system
- Generalizability - Support for the user to extend knowledge of specific interaction
- Consistency - likeness in input-output behavior arising form similar situations or similar task objectives

**Principles affecting Flexibility**
- Dialog initiative - Allowing the user freedom from artificial constraints on the input dialog imposed by the system
- Multi threading - Ability of the system to support user interaction pertaining to more than one task at a time
- Task migratability - The ability to pass control for the execution of a given task so that it becomes either internalized by the user
- Substitutivity - Allowing equivalent values of input and output to be arbitrarily substituted for each other
- Customizability - Modifiability of the user interface by the user or the system

**Principles affecting Robustness**
- Observability - Ability of the user to evaluate the internal state of the system from its perceivable representation
- Recoverability - Ability of the user to take corrective action once an error has been recognized
- Responsiveness - How the user perceives the rate of communication with the system
- Task conformance - The degree to which the system services support all of the tasks the user wishes to perform and in the way that the user understands them

**Shneiderman's 8 Golden Rules of Interface Design**

1. _Strive for consistency_ - Consistency is key to creating a user-friendly interface. Consistent placement of controls, consistent labeling, and consistent use of colors, fonts, and other design elements help users quickly learn how to use an interface and minimize confusion.
2. _Enable frequent users to use shortcuts_ - By providing shortcuts for frequently used actions, these users can perform tasks more quickly and efficiently, improving their productivity and overall satisfaction with the interface.
3. _Offer informative feedback_ - Interfaces should provide clear and immediate feedback to users when they take an action, such as clicking a button or filling out a form. Feedback helps users understand what's happening and how to proceed.
4. _Design dialogs to yield closure_ - Dialogues and other interactions should be designed to provide a clear and logical sequence of steps that help users achieve their goals. Interfaces should provide clear indications of what actions are required to complete a task.
5. _Offer error prevention and simple error_ - Interfaces should be designed to minimize the risk of user errors, such as by providing clear warnings before users take irreversible actions.
6. _Permit easy reversal of actions_ - Interfaces should allow users to undo or cancel actions easily, reducing the risk of errors and the need for user support.
7. _Support internal locus of control_ - Users should feel in control when using an interface, with clear indications of how to start, proceed, and exit a task. Interfaces should support user decision-making and provide options to personalize the experience.
8. _Reduce short-term memory load_ - Interfaces should minimize the amount of information that users need to remember, such as by providing clear labeling, organizing content in a logical manner, and using visual aids like icons and images.

**Norman's 7 Principles for transforming difficult tasks into simple ones**

1. *Use both knowledge in the world and knowledge in the head*: This principle suggests that designers should create user interfaces that use both external (knowledge in the world) and internal (knowledge in the head) resources to complete tasks. This can include providing clear instructions, feedback, and support resources.
2. *Simplify the structure of tasks*: Designers should simplify complex tasks into smaller, more manageable tasks to reduce cognitive load and make it easier for users to complete the task.
3. *Make things visible: bridge the gulfs of Execution and Evaluation*: This principle suggests that designers should make the interface and its components visible to users to reduce the gap between the user's action and the system's response. This can include providing progress bars, loading animations, or other visual cues to indicate that an action is being processed.
4. *Get the mappings right*: Designers should create a clear and intuitive relationship between the user's actions and the system's response. This can include using clear icons, labels, and feedback to guide the user through the task.
5. *Exploit the power of constraints, both natural and artificial*: Designers should use constraints to guide users towards the correct actions and prevent errors. This can include using physical constraints (such as buttons that can only be pushed in one direction) or logical constraints (such as disabling buttons until certain conditions are met).
6. *Design for error*: Designers should anticipate errors and create interfaces that help users recover from them. This can include providing clear error messages, undo/redo functions, and other support resources.
7. *When all else fails, standardize*: Designers should use familiar design patterns and interfaces to reduce the cognitive load on users. This can include using standard icons, labels, and layouts that users are already familiar with.


**ISO\IEC Standards**

1. _ISO 9241-11 : Guidance on usability_ - This standard provides guidance on usability and defines key terms related to usability. It provides a framework for understanding and evaluating usability, including the usability of software and hardware interfaces.
2. _ISO 9241-110 : Dialogue principles_ - This standard provides principles for designing effective human-computer dialogues. It covers issues such as consistency, responsiveness, and error prevention in interactive systems.
3. _ISO 9241-210 : Human-centered design for interactive systems_ - This standard provides a framework for designing interactive systems that are optimized for human use. It covers the entire design process, from initial user needs assessment to final system evaluation.
4. _*ISO 14915 : Software ergonomics for multimedia user interfaces_ - This standard provides guidance on the design of multimedia user interfaces, including visual and auditory design elements. It covers issues such as text legibility, color use, and sound quality.
5. _ISO/IEC 25010  : System and software quality models_ - This standard provides a framework for evaluating the quality of software and systems, including user interface design. It defines various quality characteristics, such as usability, accessibility, and efficiency, and provides methods for evaluating them.
6. _ISO/IEC 25060 : Common Industry Format for usability test reports_ - This standard provides a common format for reporting the results of usability testing. It provides guidelines for reporting test objectives, methods, results, and conclusions.
7. _ISO/IEC 29138 : Systems and software engineering – Lifecycle processes – Requirements engineering_ - This standard provides guidance on the requirements engineering process for software development. It covers the entire requirements engineering process, from elicitation and analysis to specification and validation.
8.  _ISO/IEC 82345 : Health software – User interface requirements and design_ - This standard provides guidance on the design of user interfaces for health software. It covers issues such as user safety, user interface design, and user feedback.
9. _ISO/IEC TR 9126-4 : Software engineering – Product quality – Part 4: Quality in use metrics_ - This standard provides guidance on evaluating software quality from the user's perspective. It defines quality in use metrics, which measure the effectiveness, efficiency, and satisfaction of software users.
10. _ISO/IEC 13407 : Human-centered design for interactive systems_  - This standard provides guidelines for designing interactive systems that are optimized for human use. It covers the entire design process, from initial user needs assessment to final system evaluation.
11.  _ISO/IEC 14598 : Software engineering – Product evaluation_ - This standard provides guidance on evaluating software products, including user interfaces. It defines evaluation methods and provides guidelines for conducting evaluations.
12. _ISO/IEC 12119 : Information technology – Guidelines for the evaluation of multimedia software_ - This standard provides guidelines for evaluating multimedia software, including user interfaces. It covers issues such as user feedback, ease of use, and multimedia quality.
13. _ISO/IEC 15504 : Information technology – Process assessment_ - This standard provides a framework for assessing the quality of software development processes. It covers issues such as process capability, process maturity, and process improvement.
14. _ISO/IEC 15939 : Software measurement – Functional size measurement_ - This standard provides a method for measuring the functional size of software products. It provides guidelines for determining the size of software modules, including user interfaces.
15. _ISO/IEC 25023: Systems and software engineering – Systems and software Quality Requirements and Evaluation (SQuaRE) – Measurement of system and software product quality_ - This standard provides guidance on measuring the quality of software products, including user interfaces. It defines quality metrics and provides guidelines for measuring them.

**The 15 Rules Every UI/UX Designer Should Know**

1. UX Isn’t Just UI
2. Know Your Audience
3. You Are Not a User
4. Adapt the Design for Short Attention Periods
5. The UX Process Is Indefinite
6. A Real Product
7. When Designing, Use Real Content 
8. Keep Things Simple and Consistent
9. Recognition Instead of Recall
10. Make Design Usable and Accessible
11. Don’t Try To Solve A Problem By Yourself
12. Don’t Try To Solve Everything At Once
13. Preventing Mistakes Is Better Than Fixing Them
14. Provide Informative Feedback
15. Avoiding Dramatic Redesigns