# Module 1

**Good and Poor design example**
- Voice mail system in Hotels
- Remote control device

**Components of Interaction Design**

*Academic disciplines*
- **E**rgonomics
- **P**sycology/Cognitive Science
- **D**esign
- **I**nformatics
- **E**ngineering
- **C**omputer Science
- **S**ocial Science

*Design practices*
- **G**raphic Design
- **P**roduct Design
- **A**rtist Design
- **I**ndustrial Design
- **F**ilm Industry

*Other*
- **U**biquitous
- **H**uman Factor (HF)
- **C**ognitive Engineering
- **H**uman Computer Interaction (HCI)
- **C**ognitive Ergonomics
- **C**omputer Supported Cooperative Work (CSCW)
- **I**nformation Systems

**Process of Interaction Design**
1. Establishing requirements
2. Designing alternatives
3. Prototyping
4. Evaluating

**Usability Goals**
- Effectiveness - effective to use
- Efficiency - efficient to use
- Safety - safe to use
- Utility - have good utility
- Learnability - easy to learn
- Memorablilty - easy to remember how to use

**User Experience Goals**
1. *Desirable aspects*
	- Satisfying, Helpful, Fun,
	- Enjoyable, Motivating, Provocative,
	- Engaging, Callenging, Surprising,
	- Pleasurable, Enhancing sociability
2. *Undesirable aspects*
	- Boring, Unpleasant, Frustrating,
	- Patronizing, Making one feel guilty,
	- Making one feel stupid, Annoying, 
	- Cutesy, Childish, Gimmicky

**Design Principles**
- Visibility
- Feedback
- Constraints
- Consistency
- Affordance

# Module 2

**Components of Conceptual models**
- Metaphors and analogies that convey to people how to understand what a product is for and how to use it for an activity (e.g. browsing, bookmarking)
- The concepts that people are exposed to through the product, including the task-domain objects they create and manipulate, their attributes and the operations that can be performed on them. (e.g. saving, revisiting, organizing)
- The relatonships between those concepts (e.g. whether one object contains another, the relative importance of actions to others and whether an object is part of another)
- The mapping between the concepts and the user experience the product is designed to support or invoke (e.g. one can revisit through looking at a list of visited sites, most-frequently visited, or saved website)

**Types of Interaction**
- Instructing
- Conversing
- Manipulating
- Exploring

**Cognitive Frameworks**
- Internal
	1. Mental models
	2. Gulf of execution and evaluation
	3. Information processing
- External
	1. Distributed cognition
	2. External cognition
	3. Embodied interaction

**Types of Social Interaction**
- Face-to-face conversation
- Remote conversation
- Telepresence
- Co-presence

# Module 3

**5 inssues of Data Gathering**
- Setting Goals
- Identifying Participants
- Relationship between Participants (data collector and data provider)
- Triangulation
- Pilot Study

**Different approaches of Data Recording**
- Notes \+ Photographs
- Audio \+ Photographs
- Video

**Data Gathering Techniques**
1. Interviews
2. Questionaires
3. Observation

**Types of Interviews**
- Open-ended / Unstructured Interview
- Structures Interview
- Semi-Structured Interview
- Focus Groups

**Types of Data Analysis**
- Quantitative Analysis
- Qualitative Analysis

**Simple Quantitaive Analysis**
- Averages
	- Mean
	- Median
	- Mode
- Percentages

**Simple Qualitative Analysis**
- Identifying recurring patterns of themes
- Categorizing data
- Looking for critical incidents

**Frameworks for Structuring the Analysis of Data gathered**
- Grounded Theory
- Distributed Cognition
- Activity Theory

**Techniques of Presenting the Findings**
- Rigorous Notations
- Using Stories
- Summarizing

**Task Description Types**
- Scenarios
- Use cases
- Essential use cases / task cases

**Type of Task Analysis**
- Hierarchical Task Analysis (HTA)



# Module 4

**Types of Prototyping**
- Low Fidelity Prototyping - Less details, doesn't look like final product
- High Fidelity Prototyping - More details looks like final product

**Compromises in Prototyping**
- Horizontal prototyping - providing wide range of functions but with little details
- Vertical prototyping - providing lots of detail for only few functions

**Principles of Conceptual Design**
- Keep and open mind but never forget the users and their context
- Discuss ideas with other stakeholders as much as possible
- Use prototyping to get rapid feedback
- Iterate, iterate and iterate

**Interface Design**
- An interface metaphor is a visual or conceptual analogy that connects the user's mental model of a familiar object or environment to the operation of a software application. 
- By using metaphors, designers can make complex software systems easier to use by leveraging the user's existing knowledge and experience.

**Steps for choosing a good Interface Metaphor**
1. Understand what the system will do (identifying the functional requirements)
2. Understand which tasks/subtasks of the product are likely to cause users problems
3. Generate metaphors

**Five Questions to ask for good metaphor**
1. How much structure does the metaphor provide?
2. How much of the metapgor is relevant to the problem?
3. Is the interface metaphor easy to represent?
4. Will your audience understant the metaphor?
5. How extensible is the metaphor?

# Module 5

**Universal Design Principles**
1. Equitable use
2. Flexibility in use
3. System be simple and intuitive to use
4. Perceptible information
5. Tolerance for error
6. Low physical effort
7. Requires size and space for approach and use

**Principles to support Usability**
- Learnability
- Flexibility
- Robustness

**Principles affecting Learnability**
- Predictability - Support for the user to determine the effect of future action based on past interaction history
- Synthesizability - Support for the user to access the affect of past operations on the current state
- Familiarity - The extent to which a user's knowledge and experience in the other real-world domains can be applied when interacting with a new system
- Generalizability - Support for the user to extend knowledge of specific interaction
- Consistency - likeness in input-output behavior arising form similar situations or similar task objectives

**Principles affecting Flexibility**
- Dialog initiative - Allowing the user freedom from artificial constraints on the input dialog imposed by the system
- Multi threading - Ability of the system to support user interaction pertaining to more than one task at a time
- Task migratability - The ability to pass control for the execution of a given task so that it becomes either internalized by the user
- Substitutivity - Allowing equivalent values of input and output to be arbitrarily substituted for each other
- Customizability - Modifiability of the user interface by the user or the system

**Principles affecting Robustness**
- Observability - Ability of the user to evaluate the internal state of the system from its perceivable representation
- Recoverability - Ability of the user to take corrective action once an error has been recognized
- Responsiveness - How the user perceives the rate of communication with the system
- Task conformance - The degree to which the system services support all of the tasks the user wishes to perform and in the way that the user understands them

**Shneiderman's 8 Golden Rules of Interface Design**

1. _Strive for consistency_ - Consistency is key to creating a user-friendly interface. Consistent placement of controls, consistent labeling, and consistent use of colors, fonts, and other design elements help users quickly learn how to use an interface and minimize confusion.
2. _Enable frequent users to use shortcuts_ - By providing shortcuts for frequently used actions, these users can perform tasks more quickly and efficiently, improving their productivity and overall satisfaction with the interface.
3. _Offer informative feedback_ - Interfaces should provide clear and immediate feedback to users when they take an action, such as clicking a button or filling out a form. Feedback helps users understand what's happening and how to proceed.
4. _Design dialogs to yield closure_ - Dialogues and other interactions should be designed to provide a clear and logical sequence of steps that help users achieve their goals. Interfaces should provide clear indications of what actions are required to complete a task.
5. _Offer error prevention and simple error_ - Interfaces should be designed to minimize the risk of user errors, such as by providing clear warnings before users take irreversible actions.
6. _Permit easy reversal of actions_ - Interfaces should allow users to undo or cancel actions easily, reducing the risk of errors and the need for user support.
7. _Support internal locus of control_ - Users should feel in control when using an interface, with clear indications of how to start, proceed, and exit a task. Interfaces should support user decision-making and provide options to personalize the experience.
8. _Reduce short-term memory load_ - Interfaces should minimize the amount of information that users need to remember, such as by providing clear labeling, organizing content in a logical manner, and using visual aids like icons and images.

**Norman's 7 Principles for transforming difficult tasks into simple ones**

1. *Use both knowledge in the world and knowledge in the head*: This principle suggests that designers should create user interfaces that use both external (knowledge in the world) and internal (knowledge in the head) resources to complete tasks. This can include providing clear instructions, feedback, and support resources.
2. *Simplify the structure of tasks*: Designers should simplify complex tasks into smaller, more manageable tasks to reduce cognitive load and make it easier for users to complete the task.
3. *Make things visible: bridge the gulfs of Execution and Evaluation*: This principle suggests that designers should make the interface and its components visible to users to reduce the gap between the user's action and the system's response. This can include providing progress bars, loading animations, or other visual cues to indicate that an action is being processed.
4. *Get the mappings right*: Designers should create a clear and intuitive relationship between the user's actions and the system's response. This can include using clear icons, labels, and feedback to guide the user through the task.
5. *Exploit the power of constraints, both natural and artificial*: Designers should use constraints to guide users towards the correct actions and prevent errors. This can include using physical constraints (such as buttons that can only be pushed in one direction) or logical constraints (such as disabling buttons until certain conditions are met).
6. *Design for error*: Designers should anticipate errors and create interfaces that help users recover from them. This can include providing clear error messages, undo/redo functions, and other support resources.
7. *When all else fails, standardize*: Designers should use familiar design patterns and interfaces to reduce the cognitive load on users. This can include using standard icons, labels, and layouts that users are already familiar with.


**ISO\IEC Standards**

1. _ISO 9241-11 : Guidance on usability_ - This standard provides guidance on usability and defines key terms related to usability. It provides a framework for understanding and evaluating usability, including the usability of software and hardware interfaces.
2. _ISO 9241-110 : Dialogue principles_ - This standard provides principles for designing effective human-computer dialogues. It covers issues such as consistency, responsiveness, and error prevention in interactive systems.
3. _ISO 9241-210 : Human-centered design for interactive systems_ - This standard provides a framework for designing interactive systems that are optimized for human use. It covers the entire design process, from initial user needs assessment to final system evaluation.
4. _*ISO 14915 : Software ergonomics for multimedia user interfaces_ - This standard provides guidance on the design of multimedia user interfaces, including visual and auditory design elements. It covers issues such as text legibility, color use, and sound quality.
5. _ISO/IEC 25010  : System and software quality models_ - This standard provides a framework for evaluating the quality of software and systems, including user interface design. It defines various quality characteristics, such as usability, accessibility, and efficiency, and provides methods for evaluating them.
6. _ISO/IEC 25060 : Common Industry Format for usability test reports_ - This standard provides a common format for reporting the results of usability testing. It provides guidelines for reporting test objectives, methods, results, and conclusions.
7. _ISO/IEC 29138 : Systems and software engineering – Lifecycle processes – Requirements engineering_ - This standard provides guidance on the requirements engineering process for software development. It covers the entire requirements engineering process, from elicitation and analysis to specification and validation.
8.  _ISO/IEC 82345 : Health software – User interface requirements and design_ - This standard provides guidance on the design of user interfaces for health software. It covers issues such as user safety, user interface design, and user feedback.
9. _ISO/IEC TR 9126-4 : Software engineering – Product quality – Part 4: Quality in use metrics_ - This standard provides guidance on evaluating software quality from the user's perspective. It defines quality in use metrics, which measure the effectiveness, efficiency, and satisfaction of software users.
10. _ISO/IEC 13407 : Human-centered design for interactive systems_  - This standard provides guidelines for designing interactive systems that are optimized for human use. It covers the entire design process, from initial user needs assessment to final system evaluation.
11.  _ISO/IEC 14598 : Software engineering – Product evaluation_ - This standard provides guidance on evaluating software products, including user interfaces. It defines evaluation methods and provides guidelines for conducting evaluations.
12. _ISO/IEC 12119 : Information technology – Guidelines for the evaluation of multimedia software_ - This standard provides guidelines for evaluating multimedia software, including user interfaces. It covers issues such as user feedback, ease of use, and multimedia quality.
13. _ISO/IEC 15504 : Information technology – Process assessment_ - This standard provides a framework for assessing the quality of software development processes. It covers issues such as process capability, process maturity, and process improvement.
14. _ISO/IEC 15939 : Software measurement – Functional size measurement_ - This standard provides a method for measuring the functional size of software products. It provides guidelines for determining the size of software modules, including user interfaces.
15. _ISO/IEC 25023: Systems and software engineering – Systems and software Quality Requirements and Evaluation (SQuaRE) – Measurement of system and software product quality_ - This standard provides guidance on measuring the quality of software products, including user interfaces. It defines quality metrics and provides guidelines for measuring them.

**The 15 Rules Every UI/UX Designer Should Know**

1. UX Isn’t Just UI
2. Know Your Audience
3. You Are Not a User
4. Adapt the Design for Short Attention Periods
5. The UX Process Is Indefinite
6. A Real Product
7. When Designing, Use Real Content 
8. Keep Things Simple and Consistent
9. Recognition Instead of Recall
10. Make Design Usable and Accessible
11. Don’t Try To Solve A Problem By Yourself
12. Don’t Try To Solve Everything At Once
13. Preventing Mistakes Is Better Than Fixing Them
14. Provide Informative Feedback
15. Avoiding Dramatic Redesigns

---
# Module 6

**4 W's of Evaluation**
1. Why Evaluate?
2. What to Evaluate?
3. Where to Evaluate?
4. When to Evaluate?

**Types of Evaluation**
1. Controlled settings involving users
2. Natural settings involving users
3. Any setting not involving users

**Case Study of Evaluation**
1. An experiment investigating a Computer Game
	- Participant response when scoring a goal against a firend versus against the computer
	- Participant response when engaging in a hockey match against a firend versus against the computer
2. In the wild study of Skiers
	- Skiers wore a helmet that had an accelerometer and a mini-camera on top of it
	- Skiers can view thier data on smartphone that includes: map of their ski runs, distance covered, duration of descent, maximum speed, and the video recorded

**Inspection methods for Interaction Design**
1. Heuristic Evaluation
2. Walkthroughs

**Nielsen’s 10 Heuristics for Evaluation:**

1. _Visibility of system status_ - Always keep users informed about what is going on, through appropriate feedback within reasonable time. For example, if a system operation will take some time, give an indication of how long and how much is complete.
2. _Match between system and the real world_ - The system should speak the user’s language, with words, phrases and concepts familiar to the user, rather than system-oriented terms. Follow real-world conventions, making information appear in natural and logical order.
3. _User control and freedom_ - Users often choose system functions by mistake and need a clearly marked ‘emergency exit’ to leave the unwanted state without having to go through an extended dialog. Support undo and redo.
4. _Consistency and standards_ - Users should not have to wonder whether words, situations or actions mean the same thing in different contexts. Follow platform conventions and accepted standards.
5. _Error prevention_ - Make it difficult to make errors. Even better than good error messages is a careful design that prevents a problem from occurring in the first place.
6. _Recognition rather than recall_ - Make objects, actions and options visible. The user should not have to remember information from one part of the dialog to another. Instructions for use of the system should be visible or easily retrievable whenever appropriate.
7. _Flexibility and efficiency of use_ - Allow users to tailor frequent actions. Accelerators – unseen by the novice user – may often speed up the interaction for the expert user to such an extent that the system can cater to both inexperienced and experienced users.
8. _Aesthetic and minimalist design_ - Dialogs should not contain information that is irrelevant or rarely needed. Every extra unit of information in a dialog competes with the relevant units of information and diminishes their relative visibility.
9. _Help users recognize, diagnose and recover from errors_ - Error messages should be expressed in plain language (no codes), precisely indicate the problem, and constructively suggest a solution.
10. _Help and documentation_ - Few systems can be used with no instructions so it may be necessary to provide help and documentation. Any such information should be easy to search, focused on the user’s task, list concrete steps to be carried out, and not be too large.

**Types of Walkthroughs**
1. Cognitive walkthrough
	- Involves simulating a user's problem-solving process at each step in the human-computer dialog, checking to see if the user's goal and memory for actions can be assured to lead to the next correct action
2. Pluralistic walkthrough
	- Users, developers and usability experts work together to step through a \[task\] scenario, discussing usability issues associated with dialog elements involved in the scenario steps

**Predictive Models**
- Fitts' Law
- GOMS family of models

**Fitts' Law**

Fitts’ law states that:
$T=k.\log_2(D/S+1.0)$
where
$T$ is time to move the pointer to a target
$D$ is distance between the pointer and the target
$S$ is size of the target
$k$ is a constant of approximately 200 ms/bit.